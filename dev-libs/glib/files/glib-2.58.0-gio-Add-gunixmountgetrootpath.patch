From f02e436fa43d51e8bec22783e2c75e345afb6e45 Mon Sep 17 00:00:00 2001
From: Ondrej Holy <oholy@redhat.com>
Date: Thu, 26 Apr 2018 10:37:33 +0200
Subject: [PATCH] gio: Add g_unix_mount_get_root_path

Currently, there isn't API to determine root path for mounts created
over bind operation (or btrfs subvolumes). This causes issues to our
volume monitors if there is multiple mounts for one device, which can
happen with libmount-based implementation currently. Let's propagate
root path from libmount over g_unix_mount_get_root_path, so we can
handle this somehow in our volume monitors.

GLIB_AVAILABLE_IN_ has to be updated accordingly before push.

https://bugzilla.gnome.org/show_bug.cgi?id=782814
---
 docs/reference/gio/gio-sections.txt |  1 +
 gio/gunixmounts.c                   | 34 ++++++++++++++++++++++++++++-
 gio/gunixmounts.h                   |  3 +++
 3 files changed, 37 insertions(+), 1 deletion(-)

diff --git a/docs/reference/gio/gio-sections.txt b/docs/reference/gio/gio-sections.txt
index 2eb7efc74..b58050f78 100644
--- a/docs/reference/gio/gio-sections.txt
+++ b/docs/reference/gio/gio-sections.txt
@@ -1545,6 +1545,7 @@ g_unix_mount_compare
 g_unix_mount_copy
 g_unix_mount_get_mount_path
 g_unix_mount_get_device_path
+g_unix_mount_get_root_path
 g_unix_mount_get_fs_type
 g_unix_mount_is_readonly
 g_unix_mount_is_system_internal
diff --git a/gio/gunixmounts.c b/gio/gunixmounts.c
index 0035d57e7..42eeb3c3c 100644
--- a/gio/gunixmounts.c
+++ b/gio/gunixmounts.c
@@ -125,6 +125,7 @@ typedef enum {
 struct _GUnixMountEntry {
   char *mount_path;
   char *device_path;
+  char *root_path;
   char *filesystem_type;
   gboolean is_read_only;
   gboolean is_system_internal;
@@ -411,6 +412,7 @@ guess_system_internal (const char *mountpoint,
 static GUnixMountEntry *
 create_unix_mount_entry (const char *device_path,
                          const char *mount_path,
+                         const char *root_path,
                          const char *filesystem_type,
                          gboolean    is_read_only)
 {
@@ -419,6 +421,7 @@ create_unix_mount_entry (const char *device_path,
   mount_entry = g_new0 (GUnixMountEntry, 1);
   mount_entry->device_path = g_strdup (device_path);
   mount_entry->mount_path = g_strdup (mount_path);
+  mount_entry->root_path = g_strdup (root_path);
   mount_entry->filesystem_type = g_strdup (filesystem_type);
   mount_entry->is_read_only = is_read_only;
 
@@ -497,6 +500,7 @@ _g_get_unix_mounts (void)
 
       mount_entry = create_unix_mount_entry (device_path,
                                              mnt_fs_get_target (fs),
+                                             mnt_fs_get_root (fs),
                                              mnt_fs_get_fstype (fs),
                                              is_read_only);
 
@@ -591,6 +595,7 @@ _g_get_unix_mounts (void)
 
       mount_entry = create_unix_mount_entry (device_path,
                                              mntent->mnt_dir,
+                                             NULL,
                                              mntent->mnt_type,
                                              is_read_only);
 
@@ -704,6 +709,7 @@ _g_get_unix_mounts (void)
 
       mount_entry = create_unix_mount_entry (mntent.mnt_special,
                                              mntent.mnt_mountp,
+                                             NULL,
                                              mntent.mnt_fstype,
                                              is_read_only);
 
@@ -770,6 +776,7 @@ _g_get_unix_mounts (void)
 
       mount_entry = create_unix_mount_entry (vmt2dataptr (vmount_info, VMT_OBJECT),
                                              vmt2dataptr (vmount_info, VMT_STUB),
+                                             NULL,
                                              fs_info == NULL ? "unknown" : fs_info->vfsent_name,
                                              is_read_only);
 
@@ -845,6 +852,7 @@ _g_get_unix_mounts (void)
 
       mount_entry = create_unix_mount_entry (mntent[i].f_mntfromname,
                                              mntent[i].f_mntonname,
+                                             NULL,
                                              mntent[i].f_fstypename,
                                              is_read_only);
 
@@ -1988,6 +1996,7 @@ g_unix_mount_free (GUnixMountEntry *mount_entry)
 
   g_free (mount_entry->mount_path);
   g_free (mount_entry->device_path);
+  g_free (mount_entry->root_path);
   g_free (mount_entry->filesystem_type);
   g_free (mount_entry);
 }
@@ -2012,6 +2021,7 @@ g_unix_mount_copy (GUnixMountEntry *mount_entry)
   copy = g_new0 (GUnixMountEntry, 1);
   copy->mount_path = g_strdup (mount_entry->mount_path);
   copy->device_path = g_strdup (mount_entry->device_path);
+  copy->root_path = g_strdup (mount_entry->root_path);
   copy->filesystem_type = g_strdup (mount_entry->filesystem_type);
   copy->is_read_only = mount_entry->is_read_only;
   copy->is_system_internal = mount_entry->is_system_internal;
@@ -2091,7 +2101,11 @@ g_unix_mount_compare (GUnixMountEntry *mount1,
   res = g_strcmp0 (mount1->device_path, mount2->device_path);
   if (res != 0)
     return res;
-	
+
+  res = g_strcmp0 (mount1->root_path, mount2->root_path);
+  if (res != 0)
+    return res;
+
   res = g_strcmp0 (mount1->filesystem_type, mount2->filesystem_type);
   if (res != 0)
     return res;
@@ -2135,6 +2149,24 @@ g_unix_mount_get_device_path (GUnixMountEntry *mount_entry)
   return mount_entry->device_path;
 }
 
+/**
+ * g_unix_mount_get_root:
+ * @mount_entry: a #GUnixMount.
+ * 
+ * Gets the root of the mount within the filesystem.
+ * 
+ * Returns: a string containing the root, or NULL.
+ *
+ * Since: 2.58
+ */
+const gchar *
+g_unix_mount_get_root_path (GUnixMountEntry *mount_entry)
+{
+  g_return_val_if_fail (mount_entry != NULL, NULL);
+
+  return mount_entry->root_path;
+}
+
 /**
  * g_unix_mount_get_fs_type:
  * @mount_entry: a #GUnixMount.
diff --git a/gio/gunixmounts.h b/gio/gunixmounts.h
index 04d6b0726..ba823748d 100644
--- a/gio/gunixmounts.h
+++ b/gio/gunixmounts.h
@@ -79,6 +79,9 @@ GLIB_AVAILABLE_IN_ALL
 const char *   g_unix_mount_get_mount_path          (GUnixMountEntry    *mount_entry);
 GLIB_AVAILABLE_IN_ALL
 const char *   g_unix_mount_get_device_path         (GUnixMountEntry    *mount_entry);
+//GLIB_AVAILABLE_IN_2_58
+GLIB_AVAILABLE_IN_ALL
+const char *   g_unix_mount_get_root_path           (GUnixMountEntry    *mount_entry);
 GLIB_AVAILABLE_IN_ALL
 const char *   g_unix_mount_get_fs_type             (GUnixMountEntry    *mount_entry);
 GLIB_AVAILABLE_IN_ALL
-- 
2.17.0
